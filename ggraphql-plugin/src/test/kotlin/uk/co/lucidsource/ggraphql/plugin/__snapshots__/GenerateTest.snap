uk.co.lucidsource.ggraphql.plugin.GenerateTest.testGenerate[/test/datafetchers/QueryListDataFetcher.kt]=[
package test.datafetchers

import com.fasterxml.jackson.databind.ObjectMapper
import graphql.schema.DataFetcher
import graphql.schema.DataFetchingEnvironment
import kotlin.Int
import kotlin.String
import test.models.TestDto
import test.models.TestDtoFilter
import test.resolvers.QueryResolver
import uk.co.lucidsource.ggraphql.api.pagination.PaginatedResult

public class QueryListDataFetcher(
  public val service: QueryResolver,
) : DataFetcher<PaginatedResult<TestDto>> {
  override fun `get`(env: DataFetchingEnvironment): PaginatedResult<TestDto> {
    val where = ObjectMapper().convertValue(env.getArgument("where"), TestDtoFilter::class.java) 
    val pageSize = env.getArgument("pageSize") as Int? 
    val cursor = env.getArgument("cursor") as String? 
    return service.list(where = where, pageSize = pageSize, cursor = cursor)
  }
}

]


uk.co.lucidsource.ggraphql.plugin.GenerateTest.testGenerate[/test/datafetchers/QueryStuffDataFetcher.kt]=[
package test.datafetchers

import graphql.schema.DataFetcher
import graphql.schema.DataFetchingEnvironment
import kotlin.collections.List
import test.models.Results
import test.resolvers.QueryResolver

public class QueryStuffDataFetcher(
  public val service: QueryResolver,
) : DataFetcher<List<Results>> {
  override fun `get`(env: DataFetchingEnvironment): List<Results> = service.stuff()
}

]


uk.co.lucidsource.ggraphql.plugin.GenerateTest.testGenerate[/test/datafetchers/TestDtoResultsDataFetcher.kt]=[
package test.datafetchers

import graphql.schema.DataFetcher
import graphql.schema.DataFetchingEnvironment
import kotlin.Int
import kotlin.String
import test.models.Results
import test.models.TestDto
import test.resolvers.TestDtoResolver
import uk.co.lucidsource.ggraphql.api.pagination.PaginatedResult

public class TestDtoResultsDataFetcher(
  public val service: TestDtoResolver,
) : DataFetcher<PaginatedResult<Results>> {
  override fun `get`(env: DataFetchingEnvironment): PaginatedResult<Results> {
    val pageSize = env.getArgument("pageSize") as Int? 
    val cursor = env.getArgument("cursor") as String? 
    return service.results(testDto = env.getSource<TestDto>(), pageSize = pageSize, cursor = cursor)
  }
}

]


uk.co.lucidsource.ggraphql.plugin.GenerateTest.testGenerate[/test/models/IdentifiedEntity.kt]=[
package test.models

import kotlin.String

public interface IdentifiedEntity {
  public val id: String?
}

]


uk.co.lucidsource.ggraphql.plugin.GenerateTest.testGenerate[/test/models/OtherDto.kt]=[
package test.models

import kotlin.String

public data class OtherDto(
  public val id: String?,
) : Results

]


uk.co.lucidsource.ggraphql.plugin.GenerateTest.testGenerate[/test/models/Results.kt]=[
package test.models

public interface Results

]


uk.co.lucidsource.ggraphql.plugin.GenerateTest.testGenerate[/test/models/TestDto.kt]=[
package test.models

import java.util.Date
import kotlin.Int
import kotlin.String

public data class TestDto(
  override val id: String?,
  public val name: String,
  public val age: Int,
  public val createAt: Date?,
) : IdentifiedEntity, Results

]


uk.co.lucidsource.ggraphql.plugin.GenerateTest.testGenerate[/test/models/TestDtoAgeFilterCriteria.kt]=[
package test.models

import com.fasterxml.jackson.`annotation`.JsonCreator
import com.fasterxml.jackson.`annotation`.JsonProperty
import kotlin.Int
import uk.co.lucidsource.ggraphql.api.filtering.FilterOperator
import uk.co.lucidsource.ggraphql.api.filtering.ast.Expression
import uk.co.lucidsource.ggraphql.api.filtering.ast.FilterUnaryExpression
import uk.co.lucidsource.ggraphql.api.filtering.expression.FilterExpression

public data class TestDtoAgeFilterCriteria @JsonCreator constructor(
  @JsonProperty("eq")
  public val eq: Int? = null,
  @JsonProperty("gt")
  public val gt: Int? = null,
  @JsonProperty("gtEq")
  public val gtEq: Int? = null,
  @JsonProperty("lt")
  public val lt: Int? = null,
  @JsonProperty("ltEq")
  public val ltEq: Int? = null,
) : FilterExpression {
  override fun ast(): Expression {

                        if (`eq` != null) {
                            return FilterUnaryExpression(field = "age", operator =
        FilterOperator.EQ, value = `eq`)
                        }
                
                        if (`gt` != null) {
                            return FilterUnaryExpression(field = "age", operator =
        FilterOperator.GT, value = `gt`)
                        }
                
                        if (`gtEq` != null) {
                            return FilterUnaryExpression(field = "age", operator =
        FilterOperator.GT_EQ, value = `gtEq`)
                        }
                
                        if (`lt` != null) {
                            return FilterUnaryExpression(field = "age", operator =
        FilterOperator.LT, value = `lt`)
                        }
                
                        if (`ltEq` != null) {
                            return FilterUnaryExpression(field = "age", operator =
        FilterOperator.LT_EQ, value = `ltEq`)
                        }
                return Expression.EMPTY_EXPRESSION
  }
}

]


uk.co.lucidsource.ggraphql.plugin.GenerateTest.testGenerate[/test/models/TestDtoFilter.kt]=[
package test.models

import com.fasterxml.jackson.`annotation`.JsonCreator
import com.fasterxml.jackson.`annotation`.JsonProperty
import kotlin.collections.List
import uk.co.lucidsource.ggraphql.api.filtering.FilterGroupOperator
import uk.co.lucidsource.ggraphql.api.filtering.ast.Expression
import uk.co.lucidsource.ggraphql.api.filtering.ast.FilterGroupCompoundExpression
import uk.co.lucidsource.ggraphql.api.filtering.expression.FilterExpression

public data class TestDtoFilter @JsonCreator constructor(
  @JsonProperty("all")
  public val all: List<TestDtoFilterCriteria>? = null,
  @JsonProperty("not")
  public val not: List<TestDtoFilterCriteria>? = null,
  @JsonProperty("any")
  public val any: List<TestDtoFilterCriteria>? = null,
) : FilterExpression {
  override fun ast(): Expression {
    val all = FilterGroupCompoundExpression(FilterGroupOperator.ALL, all?.map { it.ast() }?.filter {
        it != Expression.EMPTY_EXPRESSION } ?: emptyList())
    val not = FilterGroupCompoundExpression(FilterGroupOperator.NOT, not?.map { it.ast() }?.filter {
        it != Expression.EMPTY_EXPRESSION } ?: emptyList())
    val any = FilterGroupCompoundExpression(FilterGroupOperator.ANY, any?.map { it.ast() }?.filter {
        it != Expression.EMPTY_EXPRESSION } ?: emptyList())

                  val filters = listOf(all,not,any).filter{ it.expressions.isNotEmpty() }
                  if(filters.isEmpty()) {
                      return Expression.EMPTY_EXPRESSION
                  }
                  return FilterGroupCompoundExpression(FilterGroupOperator.ALL, filters)
                
  }
}

]


uk.co.lucidsource.ggraphql.plugin.GenerateTest.testGenerate[/test/models/TestDtoFilterCriteria.kt]=[
package test.models

import com.fasterxml.jackson.`annotation`.JsonCreator
import com.fasterxml.jackson.`annotation`.JsonProperty
import uk.co.lucidsource.ggraphql.api.filtering.FilterGroupOperator
import uk.co.lucidsource.ggraphql.api.filtering.ast.Expression
import uk.co.lucidsource.ggraphql.api.filtering.ast.FilterGroupCompoundExpression
import uk.co.lucidsource.ggraphql.api.filtering.expression.FilterExpression

public data class TestDtoFilterCriteria @JsonCreator constructor(
  @JsonProperty("name")
  public val name: TestDtoNameFilterCriteria? = null,
  @JsonProperty("age")
  public val age: TestDtoAgeFilterCriteria? = null,
) : FilterExpression {
  override fun ast(): Expression {
    val fieldExpressions = listOf(name,age).filterNotNull().map { it.ast() }.filter { it !=
        Expression.EMPTY_EXPRESSION }
    if(fieldExpressions.isEmpty()) {
        return Expression.EMPTY_EXPRESSION
    }
    return FilterGroupCompoundExpression(FilterGroupOperator.ALL, fieldExpressions)
  }
}

]


uk.co.lucidsource.ggraphql.plugin.GenerateTest.testGenerate[/test/models/TestDtoNameFilterCriteria.kt]=[
package test.models

import com.fasterxml.jackson.`annotation`.JsonCreator
import com.fasterxml.jackson.`annotation`.JsonProperty
import kotlin.String
import uk.co.lucidsource.ggraphql.api.filtering.FilterOperator
import uk.co.lucidsource.ggraphql.api.filtering.ast.Expression
import uk.co.lucidsource.ggraphql.api.filtering.ast.FilterUnaryExpression
import uk.co.lucidsource.ggraphql.api.filtering.expression.FilterExpression

public data class TestDtoNameFilterCriteria @JsonCreator constructor(
  @JsonProperty("eq")
  public val eq: String? = null,
) : FilterExpression {
  override fun ast(): Expression {

                        if (`eq` != null) {
                            return FilterUnaryExpression(field = "name", operator =
        FilterOperator.EQ, value = `eq`)
                        }
                return Expression.EMPTY_EXPRESSION
  }
}

]


uk.co.lucidsource.ggraphql.plugin.GenerateTest.testGenerate[/test/resolvers/GraphQLCodeDataFetcherRegistry.kt]=[
package test.resolvers

import graphql.schema.FieldCoordinates
import graphql.schema.GraphQLCodeRegistry
import test.datafetchers.QueryListDataFetcher
import test.datafetchers.QueryStuffDataFetcher
import test.datafetchers.TestDtoResultsDataFetcher

public class GraphQLCodeDataFetcherRegistry(
  public val queryResolver: QueryResolver,
  public val testDtoResolver: TestDtoResolver,
) {
  public fun registerResolvers(graphQLCodeRegistry: GraphQLCodeRegistry.Builder):
      GraphQLCodeRegistry.Builder {
    graphQLCodeRegistry.dataFetcher(FieldCoordinates.coordinates("Query", "stuff"),
        QueryStuffDataFetcher(queryResolver))
    graphQLCodeRegistry.dataFetcher(FieldCoordinates.coordinates("Query", "list"),
        QueryListDataFetcher(queryResolver))
    graphQLCodeRegistry.dataFetcher(FieldCoordinates.coordinates("TestDto", "results"),
        TestDtoResultsDataFetcher(testDtoResolver))
    return graphQLCodeRegistry
  }
}

]


uk.co.lucidsource.ggraphql.plugin.GenerateTest.testGenerate[/test/resolvers/QueryResolver.kt]=[
package test.resolvers

import kotlin.Int
import kotlin.String
import kotlin.collections.List
import test.models.Results
import test.models.TestDto
import test.models.TestDtoFilter
import uk.co.lucidsource.ggraphql.api.pagination.PaginatedResult

public interface QueryResolver {
  public fun stuff(): List<Results>

  public fun list(
    `where`: TestDtoFilter?,
    pageSize: Int?,
    cursor: String?,
  ): PaginatedResult<TestDto>
}

]


uk.co.lucidsource.ggraphql.plugin.GenerateTest.testGenerate[/test/resolvers/TestDtoResolver.kt]=[
package test.resolvers

import kotlin.Int
import kotlin.String
import test.models.Results
import test.models.TestDto
import uk.co.lucidsource.ggraphql.api.pagination.PaginatedResult

public interface TestDtoResolver {
  public fun results(
    pageSize: Int?,
    cursor: String?,
    testDto: TestDto,
  ): PaginatedResult<Results>
}

]


uk.co.lucidsource.ggraphql.plugin.GenerateTest.testGenerate[/test/wiring/IdentifiedEntityTypeResolver.kt]=[
package test.wiring

import graphql.TypeResolutionEnvironment
import graphql.schema.GraphQLObjectType
import graphql.schema.TypeResolver
import java.lang.IllegalArgumentException
import test.models.TestDto

public class IdentifiedEntityTypeResolver : TypeResolver {
  override fun getType(env: TypeResolutionEnvironment): GraphQLObjectType {

                val javaObject = env.getObject<Any>()
                return when(javaObject) {
            is TestDto -> env.getSchema().getObjectType("TestDto")
    else -> throw IllegalArgumentException("Unexpected type in type resolver ${javaObject}")
    }
  }
}

]


uk.co.lucidsource.ggraphql.plugin.GenerateTest.testGenerate[/test/wiring/ResultsTypeResolver.kt]=[
package test.wiring

import graphql.TypeResolutionEnvironment
import graphql.schema.GraphQLObjectType
import graphql.schema.TypeResolver
import java.lang.IllegalArgumentException
import test.models.OtherDto
import test.models.TestDto

public class ResultsTypeResolver : TypeResolver {
  override fun getType(env: TypeResolutionEnvironment): GraphQLObjectType {

                val javaObject = env.getObject<Any>()
                return when(javaObject) {
            is TestDto -> env.getSchema().getObjectType("TestDto")
    is OtherDto -> env.getSchema().getObjectType("OtherDto")
    else -> throw IllegalArgumentException("Unexpected type in type resolver ${javaObject}")
    }
  }
}

]


uk.co.lucidsource.ggraphql.plugin.GenerateTest.testGenerate[/test/wiring/TypeResolverWiring.kt]=[
package test.wiring

import graphql.schema.idl.RuntimeWiring
import graphql.schema.idl.TypeRuntimeWiring

public object TypeResolverWiring {
  public fun wireTypeResolvers(wiring: RuntimeWiring.Builder): RuntimeWiring.Builder {

                wiring.type(
                    TypeRuntimeWiring.newTypeWiring("Results")
                        .typeResolver(test.wiring.ResultsTypeResolver()).build()
                )
                
                wiring.type(
                    TypeRuntimeWiring.newTypeWiring("IdentifiedEntity")
                        .typeResolver(test.wiring.IdentifiedEntityTypeResolver()).build()
                )
                return wiring
  }
}

]


uk.co.lucidsource.ggraphql.plugin.GenerateTest.testGenerate[generated-files]=[
/test/datafetchers/QueryStuffDataFetcher.kt,/test/datafetchers/TestDtoResultsDataFetcher.kt,/test/datafetchers/QueryListDataFetcher.kt,/test/wiring/IdentifiedEntityTypeResolver.kt,/test/wiring/ResultsTypeResolver.kt,/test/wiring/TypeResolverWiring.kt,/test/resolvers/QueryResolver.kt,/test/resolvers/GraphQLCodeDataFetcherRegistry.kt,/test/resolvers/TestDtoResolver.kt,/test/models/IdentifiedEntity.kt,/test/models/OtherDto.kt,/test/models/TestDtoFilterCriteria.kt,/test/models/Results.kt,/test/models/TestDtoFilter.kt,/test/models/TestDto.kt,/test/models/TestDtoAgeFilterCriteria.kt,/test/models/TestDtoNameFilterCriteria.kt
]


uk.co.lucidsource.ggraphql.plugin.GenerateTest.testGenerate[schema.graphql]=[
interface IdentifiedEntity {
  id: String
}

union Results = OtherDto | TestDto

type OtherDto {
  id: String
}

type Query {
  list(cursor: String, pageSize: Int = 10, where: TestDtoFilter): TestDtoPaginatedResult!
  stuff: [Results!]!
}

type ResultsPaginatedResult {
  nextCursor: String
  nodes: [Results!]!
  pageNumber: Int!
  previousCursor: String
  total: Int!
}

type TestDto implements IdentifiedEntity {
  age: Int!
  createAt: DateTime
  id: String
  name: String!
  results(cursor: String, pageSize: Int = 10): ResultsPaginatedResult!
}

type TestDtoPaginatedResult {
  nextCursor: String
  nodes: [TestDto!]!
  pageNumber: Int!
  previousCursor: String
  total: Int!
}

enum FilterOperator {
  EQ
  GT
  GT_EQ
  IN
  LIKE
  LT
  LT_EQ
}

scalar DateTime

input TestDtoAgeFilterCriteria {
  eq: Int
  gt: Int
  gtEq: Int
  lt: Int
  ltEq: Int
}

input TestDtoFilter {
  all: [TestDtoFilterCriteria!]
  any: [TestDtoFilterCriteria!]
  not: [TestDtoFilterCriteria!]
}

input TestDtoFilterCriteria {
  age: TestDtoAgeFilterCriteria
  name: TestDtoNameFilterCriteria
}

input TestDtoNameFilterCriteria {
  eq: String
}

]